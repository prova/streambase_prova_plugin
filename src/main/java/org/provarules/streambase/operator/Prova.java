package org.provarules.streambase.operator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.provarules.streambase.EngineResults;
import org.provarules.streambase.EventProcessingEngine;
import org.provarules.streambase.ProvaEngineImpl;
import org.slf4j.Logger;

import org.provarules.kernel2.ProvaConstant;
import org.provarules.reference2.ProvaMapImpl;

import com.streambase.sb.Schema;
import com.streambase.sb.StreamBaseException;
import com.streambase.sb.Tuple;
import com.streambase.sb.TupleException;
import com.streambase.sb.Schema.Field;
import com.streambase.sb.operator.Operator;
import com.streambase.sb.operator.Parameterizable;
import com.streambase.sb.operator.PortCounts;
import com.streambase.sb.operator.TypecheckException;

/**
 * Generated by JDT StreamBase Client Templates (Version: 7.2.5.1204131423).
 * 
 * This class is used as a Java Operator in a StreamBase application. One
 * instance will be created for each Java Operator in a StreamBase application.
 * <p>
 * Enqueue methods should only be called from processTuple.
 * <p>
 * If there is any state that the operator instance needs to maintain beyond the
 * lifetime of the instance, the setSessionState/getSessionState methods can be
 * used.
 * 
 * @see Parameterizable
 * @see Operator For in-depth information on implementing a custom Java
 *      Operator, please see "Developing StreamBase Java Operators" in the
 *      StreamBase documentation.
 */
public class Prova extends Operator implements Parameterizable, EngineResults {

	public static final long serialVersionUID = 1336836590771L;
//	private static long count = 0L;
	private Logger logger;
	// Properties
	private String rulebase = "";
	private String properties = "";

	private String displayName = "Prova";
	// Local variables
	private int inputPorts = 1;
//	private int outputPorts = 1;
//	private int nextOutputPort = 0;
	
	// Cache the Schemas given during typecheck for use at processTuple
	private List<Schema> outputSchemas = new ArrayList<>();

//	private Schema inSchema; // input to this operator
//	private Schema outSchema; // output from this schema
//	private Schema.Field[] fields; // individual fields in the schema
	private EventProcessingEngine engine;

	/**
	 * The constructor is called when the Operator instance is created, but
	 * before the Operator is connected to the StreamBase application. We
	 * recommended that you set the initial input port and output port count in
	 * the constructor by calling setPortHints(inPortCount, outPortCount). The
	 * default is 1 input port, 1 output port. The constructor may also set
	 * default values for operator parameters. These values will be displayed in
	 * StreamBase Studio when a new instance of this operator is dragged to the
	 * canvas, and serve as the default values for omitted optional parameters.
	 */
	public Prova() {
		super();

		logger = getLogger();
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		// if( rulebase.equals("") )
		setPortHints(inputPorts, 1);
		setRulebase(rulebase);
		setProperties(properties);
	}

	@Override
	public PortCounts getPortCounts() throws TypecheckException {
		Schema[][] schemas = getSchemas("basic");
		Schema[] inputSchemas = schemas[0];
		Schema[] outputSchemas = schemas[1];
		Schema[] outputEnrichmentSchemas = schemas[2];
		return new PortCounts(inputSchemas.length, outputSchemas.length + outputEnrichmentSchemas.length);
	}

	private Schema[][] getSchemas(final String key) throws TypecheckException {
		EventProcessingEngine engine0 = null;
		try {
			engine0 = new ProvaEngineImpl(getRulebase());
			return engine0.init(key);
		} catch (Exception e) {
			throw new PropertyTypecheckException("Could not start the Prova query in "
					+ getRulebase(), "");
		} finally {
			if (engine0 != null)
				engine0.shutdown();
			engine0 = null;
		}
	}

	/**
	 * The typecheck method is called after the Operator instance is connected
	 * in the StreamBase application, allowing the Operator to validate its
	 * properties. The Operator class may change the number of input or output
	 * ports by calling the requireInputPortCount(portCount) method or the
	 * setOutputSchema(schema, portNum) method. If the verifyInputPortCount
	 * method is passed a different number of ports than the Operator currently
	 * has, a PortMismatchException (subtype of TypecheckException) is thrown.
	 */
	public void typecheck() throws TypecheckException {
		// TODO Ensure that all properties have valid values

		Schema[][] schemas = getSchemas("basic");
		Schema[] inputSchemas = schemas[0];
		int inputPorts = inputSchemas.length;

		// typecheck: require a specific number of input ports
		requireInputPortCount(inputPorts);
		for (int i = 0; i < inputPorts; ++i) {
			Schema actualSchema = getInputSchema(i);
			if (logger.isInfoEnabled()) {
				logger.info("required input schema " + i + ": "
						+ inputSchemas[i].toHumanString());
				logger.info("  actual input schema " + i + ": "
						+ actualSchema.toHumanString());
			}
			// Type-check schemas so that all the required fields are
			// present in the actual schema
			if (!actualSchema.isSupersetOf(inputSchemas[i]))
				throw new PropertyTypecheckException (
						"Input schema does not match the fields required by the operator.", "");
		}

		outputSchemas.clear();
		outputSchemas.addAll(Arrays.asList(schemas[1]));
		int outputPorts = schemas[1].length;
		for (int i = 0; i < outputPorts; ++i)
			setOutputSchema(i, schemas[1][i]);
		
		if (schemas[2].length == 0)
			return;
		
		// Add the declared enrichment schemas
		int outputEnrichmentPorts = schemas[2].length;
		Schema firstInputSchema = getInputSchema(0);
		for (int i = 0; i < outputEnrichmentPorts; ++i) {
			List<Field> fields = new ArrayList<Field>();
			for(Field f : firstInputSchema.getFields())
				fields.add(f);
			for(Field f : schemas[2][i].getFields())
				fields.add(f);
			Schema enrichmentSchema = new Schema(null, fields);
			outputSchemas.add(enrichmentSchema);
			setOutputSchema(i+outputPorts, enrichmentSchema);
		}
	}

	/**
	 * If typecheck succeeds, the init method is called before the StreamBase
	 * application is started. Note that your Operator class is not required to
	 * define the init method, unless (for example) you need to perform
	 * initialization of a resource such as a JDBC pool, if your operator is
	 * making JDBC calls. StreamBase Studio does not call this during authoring.
	 */
	public void init() throws StreamBaseException {
		super.init();

		engine = new ProvaEngineImpl(getRulebase());
		final Map<String, Object> parms = new HashMap<String, Object>();
		parms.put("queryId", "1");
		parms.put("result", this);
		try {
			String[] pairs = properties.split(",");
			if( pairs!=null && pairs.length!=0 ) {
				for( String pair : pairs ) {
					String[] keyValue = pair.split("=");
					if( keyValue.length==2 )
						parms.put(keyValue[0], keyValue[1]);
				}
			}
			engine.start("basic", parms);
		} catch (Exception e) {
			logger.error("Could not start the Prova query in " + getRulebase());
		}

	}

	/**
	 * This method will be called by the StreamBase server for each Tuple given
	 * to the Operator to process. This is the only time an operator should
	 * enqueue output Tuples.
	 * 
	 * @param inputPort
	 *            the input port that the tuple is from (ports are zero based)
	 * @param tuple
	 *            the tuple from the given input port
	 * @throws StreamBaseException
	 *             Terminates the application.
	 */
	public void processTuple(int inputPort, Tuple tuple)
			throws StreamBaseException {
		if (logger.isDebugEnabled()) {
			logger.debug("operator processing a tuple at input port" + inputPort);
		}

		// send the input to the Prova engine
		final Map<String, Object> msg = new HashMap<String, Object>();
		msg.put("event", ProvaMapImpl.wrapValues(tuple.getFields()));
		msg.put("result", this);
		msg.put("port", inputPort);
		final Map<String, Object> properties = new HashMap<String, Object>();
		properties.put("queryId", "1");
		engine.addMsg(msg, properties);
	}

	@Override
	public void callback(int port, Map<String, Object> result) {
		final Schema outSchema = outputSchemas.get(port);
		// create a new output tuple from the Schema at the port we are about to
		// send to
		final Tuple out = outSchema.createTuple();
		final Map<String, Object> map = new HashMap<>();
		for( Iterator<Entry<String, Object>> iter = result.entrySet().iterator();  iter.hasNext(); ) {
			Entry<String, Object> entry = iter.next();
			if (!outSchema.hasField(entry.getKey()))
				continue;
			final Object value = entry.getValue();
			if( value instanceof ProvaConstant )
				map.put(entry.getKey(), ((ProvaConstant) value).getObject());
			else
				map.put(entry.getKey(), value);
		}
		try {
			out.setFields(map);
			if (logger.isDebugEnabled()) {
				logger.debug("Callback for port" + port + ": " + out);
			}
			sendOutput(port, out);
		} catch (TupleException e) {
			logger.error("Tuple processing error for " + result);
		} catch (StreamBaseException e) {
			logger.error("Error while sending output for " + result);
		}
		/*
		 * // TODO this template just copies each field value from input port 0
		 * (the first input port) for (int i = 0; i <
		 * out.getSchema().getFieldCount(); ++i) { // note: best performance is
		 * achieved retrieving values through Tuple#getField(Schema.Field)
		 * out.setField(i, tuple.getField(i)); }
		 */
	}

	/**
	 * The shutdown method is called when the StreamBase server is in the
	 * process of shutting down.
	 */
	public void shutdown() {
		if (engine != null)
			engine.shutdown();
		engine = null;
		outputSchemas = null;
	}

	/***************************************************************************************
	 * The getter and setter methods provided by the Parameterizable object. *
	 * StreamBase Studio uses them to determine the name and type of each
	 * property * and obviously, to set and get the property values. *
	 ***************************************************************************************/

	public void setRulebase(String rulebase) {
		this.rulebase = rulebase;
	}

	public String getRulebase() {
		return this.rulebase;
	}

	/**
	 * For detailed information about shouldEnable methods, see interface
	 * Parameterizable java doc
	 * 
	 * @see Parameterizable
	 */

	public boolean shouldEnableRulebase() {
		return true;
	}

	// public int getOutputPorts() {
	// return outputPorts;
	// }
	//
	// public void setOutputPorts(int outputPorts) {
	// this.outputPorts = outputPorts;
	// }
	//
	public boolean shouldEnableOutputPorts() {
		return true;
	}

	public String getProperties() {
		return properties;
	}

	public void setProperties(String properties) {
		this.properties = properties;
	}

	public boolean shouldEnableMaxwait() {
		return true;
	}

}
